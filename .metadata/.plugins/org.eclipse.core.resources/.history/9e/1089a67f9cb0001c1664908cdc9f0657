package com.ict.controller;

import java.io.UnsupportedEncodingException;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import oracle.jdbc.proxy.annotation.Post;

// 어노테이션 네 종류가 있었는데(@Component, @Repository, @Controller, @Service)
// 컨트롤러를 만드는 경우이니 당연히 @Controller를 씁니다.
@Controller
public class BasicController {
	
	//RequestMapping의 value는 localhost:8181/어떤 주소로 접속시 해당 로직이 실행될지 결정합니다.
	//아무것도 안 적으면 기본적으로 get방식을 허용합니다.
	@RequestMapping(value="/goA")
	// 아래에 해당 주소로 접속시 실행하고 싶은 메서드를 작성합니다.
	public String goA() {
		System.out.println("goA 접속이 감지되었습니다.");
		
		// return "goA"; 라고 적으면 VIEWS폴더 내부의 goA.jsp파일을 보여줍니다.
		
		return "goA";
	}
	
// /goB로 접속했을때 실행되는 b.jsp 창이 열리도록 아래에 세팅해주세요.
	
	@RequestMapping(value="/goB")
	public String go() {
		System.out.println("goB 접속이 감지되었습니다.");
		return "b";
	}
	
	// 여러분들의 성씨 기준("/kim") 으로 패턴을 잡고 
	// 결과 페이지는"
	
	@RequestMapping(value="/kim")
	public String a() {
		System.out.println("kim접속이 감지되었습니다.");
		return "muhwan";
	}
	
	// 외부에서 전송하는 데이터는 메서드 선언부에 선언된 변수로 받습니다.
	// 이름만 일치하면 알아서 받아옵니다.
	// 자료형을 신경쓸 필요가 없습니다.
	@RequestMapping(value="/getData", method=RequestMethod.POST)//localhost:8181/getData
	                // /getDate?data1=데이터1&data2=데이터2 에 해당하는 요소를 받아옵니다.
	public String getData(String data1, int data2, Model model) {// 한글 인코딩 
	                                          
		
		//String data1, = request.getParameter("data1");//jsp때 데이터를 
		// int data2 = Integer.parseInt(strData2);//
		System.out.println("data1에 든 값 :" + data1);
		System.out.println("data2에 든 값 :" + data2);
		System.out.println("data2가 정수임을 증명 :" + (data2+100));
		// data1, data2 변수를 getResult.jsp
		 
		model.addAttribute("data11",data1);
		model.addAttribute("data22",data2);
		
		return "getResult";
	}
	
	
	// 외부에서 전송하는 데이터를 /getMoney 주소로 받아오겠습니다.
	// 이 주소는 int won 이라는 형식으로 금액을 받아서 
	// 환율에 따른 환전 금액을 콘솔에 찍어줍니다.
	// 결과페이지는 exchange.jsp로 하겠습니다.
	// 메서드명은 임의로 만들어주세요.
	
	@RequestMapping(value="/getMoney", method =RequestMethod.POST)//post방식으로만 받도록 처리
	              //포워딩시 바인딩을 하고 싶다면 Model을 선언합니다.
	public String getNewYork(int won, Model model) {
		System.out.println("입력한 금액은 :" + won +"원 입니다.");
		System.out.println("현재 달러의 환율은 1,219.99원당 1달러입니다.");
		System.out.println("입력한 금액에 따른 환전 금액은 "+ (won / 1219.99) +"달러 입니다.");
	      double result = (won / 1219.99);
		
				// model.addAttribute("보낼 이름", 보낼자료);
		// 넘어간 데이터는.jsp파엘에서 el을 이용해 출력합니다.
		// ex - > model.addAttribute"test",자료);로 바인딩한 경우
		// ${test} 로 .jsp에서 출력 가능
	 	
	 	model.addAttribute("result",result);
		model.addAttribute("won1",won);
		// won변수에 해당하는 변수도 추가로 보내보세요.
		//exchange.jsp를 타겟으로 하니 views폴더에 생성해주세요.
		return "exchange";
	}
	
	// form 페이지와 결과 페이지를 분리해야합니다.
	// 다만 목적지 주소가 . jsp기준이 아닌, @RequestMapping상의 주소기준으로 갑니다.
	// 주소 moneyForm으로 연결되도록 아래에 어노테이션 + 메서드를 구성해주세요.
	// moneyForm.jsp로 연결됩니다.
	// moneyForm.jsp에는 목적지를 #으로 하고
	// name=won 인 폼을 추가로 만들어주세요.
	
	//1. @RequestMapping에 어떤 주소로 접속해야 하는지 적는다.
	@RequestMapping(value="/moneyForm") 
	// 2. public String 메서드()를 만든다.
	public String getNewYork( ) {
		
		return "moneyForm";
	}
	
	// 상단 /getData 주소를 타겟으로 하는 /dataForm을 만들어주세요.
	// data1, data2를 자료형에 맞게 폼으로 입력받아 전송버튼을 누르면
	// 해당 데이터가 결과 페이지에 나올 수 있도록 .jsp파일부터 시작해서
	// form태그나 세부 로직까지 완성시켜주세요.
	@GetMapping(value="/dataForm1")
	public String Data() {
		return "dataForm";
	}
	
	// 스프링 5버전부터 허용
	//@요청메서드Mapping 은 해당 메서드만 허용하는 어노테이션입니다.
	@GetMapping(value="/onlyGet")
	public String onlyGet() {
		return "onlyGet";
	}
	
	
	
	// 성적 입력 폼 접근 로직
	@GetMapping(value="/score")
	public String getGrade() {
		return "/grade_cardForm";                         
	
}
	
	
	// 성적 결과 페이지 접근 로직
		@RequestMapping(value="/score",method=RequestMethod.POST)
		                    // 컴퓨터가 폼에서는 computer으로 왔는데 바인딩할때 com으로 해야할때는 @RequestParam("computer")을 int com 앞에붙이면된다.
		  public String getGrade(int math, int eng, int lan, int social,@RequestParam("computer") int com, Model model ) {
			int total = (math + eng + lan + social + com);
			double avg = (total /5.0);
			
			//바인딩
			model.addAttribute("math", math);
			model.addAttribute("eng", eng);
			model.addAttribute("lan", lan);
			model.addAttribute("social", social);
			model.addAttribute("com", com);
			model.addAttribute("total", total);
			model.addAttribute("avg", avg);
			
			return "scoreResult";
		}
		
		
		        // 주소는 /page로 하겠습니다.
				// get방식 접속만 허용합니다.
				// 메서드명은 임의로 만들어주세요.
				// page.jsp로 연결됩니다.
		@GetMapping(value="/page/{bookNum}/{pageNum}")
		public String getpage(@PathVariable int pageNum, 
				              @PathVariable int bookNum,
				               Model model) {
			// page.jsp를 views폴더에 만들어주세요.
			// 해당 페이지는 int pageNum을 받아서 바인딩합니다.
			// page.jsp 본문에 현재 ${page}페이지를 보고 계십니다.
			// 와 함께 입숨 더미데이터를 이용해 본문글을 채워주세요.
			
			model.addAttribute("page",pageNum);
			model.addAttribute("book",bookNum);
			return "page";
		}
		
	
		// 환율 계산기를 만들어 보겠습니다.
		// 단, 원화 금액은 @PathVariable을 이용해 입력받습니다.
		// 주소는 /rate입니다.
		// get방식으로 처리해주세요.
		// 원화를 입력받으면 rate.jsp에서 결과로 환전금액을 보여줍니다.
		
		
		@GetMapping(value="/rate/{money}")
		public String getRate(@PathVariable int money, Model model) {
			double result = (money/1209.80);
			model.addAttribute("money", money);
			model.addAttribute("result", result);
			
			return "rate";
		}
		
		
		
		
		
		
	
	
}